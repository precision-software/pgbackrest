/***********************************************************************************************************************************
Recursive scan of a directory.
***********************************************************************************************************************************/
#include "build.auto.h"

#include "storage/scan.h"
#include "storage/storage.h"
#include "storage/list.h"
#include "storage/info.h"
#include "common/type/string.h"
#include "common/type/object.h"


/****Belongs in string.h  or a path manipulation library.  ******/

/***********************************************************************************************************************************

 * @param path
 * @param subPath
***********************************************************************************************************************************/
static String *
strPathJoin(const String *path, const String *subPath)
{
    String *joined;
    if (path == NULL && subPath == NULL)
        joined = NULL;
    else if (path == NULL)
        joined = strDup(subPath);
    else if (subPath == NULL)
        joined = strDup(path);
    else
        joined = strNewFmt("%s/%s", strZ(path), strZ(subPath));

    return joined;
}

/*** belongs in storage/list.h. Enables iterating through StorageList **********/

// Convert StorageList to an abstract Collection.
#define CAMEL_StorageList storageLst
typedef struct StorageListItr
{
    StorageList *list;
    unsigned int idx;
    StorageInfo info;
}StorageListItr;

StorageListItr *
storageLstItrNew(StorageList *list)
{
    StorageListItr *this;
    OBJ_NEW_BEGIN(StorageListItr, .childQty=MEM_CONTEXT_QTY_MAX, .allocQty=MEM_CONTEXT_QTY_MAX);
        this = OBJ_NEW_ALLOC();
        *this = (StorageListItr){.list=list, .idx=0};
    OBJ_NEW_END();

    return this;
}

StorageInfo *
storageLstItrNext(StorageListItr *this)
{
    return (this->idx >= storageLstSize(this->list))
        ? NULL
        : (this->info = storageLstGet(this->list, this->idx++), &this->info);
}

StorageInfo *
storageInfoUpdatePath(StorageInfo *info, String *parentPath)
{
    StorageInfo *this;
    OBJ_NEW_BEGIN(StorageInfo, .childQty=MEM_CONTEXT_QTY_MAX, .allocQty=MEM_CONTEXT_QTY_MAX)

        // Copy everything except the name. TODO: This copy can be refined by looking at retVal level.
        this = OBJ_NEW_ALLOC();
        *this = *info;

        // Fill in the complete name by joining the directory path with the file name.
        this->name = strPathJoin(parentPath, info->name);
    OBJ_NEW_END();

    return this;
}

StorageInfo *
storageInfoClone(StorageInfo *info)
{
    return (info == NULL)? NULL: storageInfoUpdatePath(info, NULL);
}


/***** Now we are doing our own thing ***************/

/***********************************************************************************************************************************
A "lazy-container" of files which will be generated by recursively scanning through a directory.
***********************************************************************************************************************************/
typedef struct RecursiveScan
{
    Storage *driver;                                                // The relevant storage driver
    String *path;                                                   // Path to the relevant directory
    StorageScanParams param;                                        // Parameters describing the scan.
    bool postOrder;
} RecursiveScan;

// Enable use of FOREACH and containerNew().
#define CAMEL_RecursiveScan  recursiveScan

/***********************************************************************************************************************************
A "helper-iterator" to scan files contained in a single directory.
***********************************************************************************************************************************/
typedef struct SubdirItr
{
    CollectionItr *files;                                           // Iterator scanning each file in directory.
    StorageInfo *postponed;                                         // Postorder directory output after the contents.

    // The following fields are all NULL for the root directory.
    struct SubdirItr *parent;                                       // Pointer to our parent directory iterator.
    String *path;                                                   // Path to the current directory, relative to start.
} SubdirItr;


/***********************************************************************************************************************************
"lazy iterator" to recursively scan through a directory and its subdirectories.
***********************************************************************************************************************************/
typedef struct RecursiveScanItr
{
    RecursiveScan *scan;                                               // Point to the scan we are doing.
    SubdirItr *current;                                             // the current subdirectory iterator.
    StorageInfo *info;                                              // The file info we output last iteration.
    MemContext *ctx;                                                // Memory context of the iterator.
} RecursiveScanItr;

/***********************************************************************************************************************************
Construct a "lazy-container" of files which will be found by recursively scanning through the directory.
***********************************************************************************************************************************/
RecursiveScan *
recursiveScanNew(Storage *driver, String *path, StorageScanParams param)
{
    RecursiveScan *this;
    OBJ_NEW_BEGIN(RecursiveScan, .childQty=MEM_CONTEXT_QTY_MAX, .allocQty=MEM_CONTEXT_QTY_MAX)
        this = OBJ_NEW_ALLOC();
        *this = (RecursiveScan) {
            .driver = driver,
            .path = strDup(path),
            .param = param,
            .postOrder = param.sortOrder != sortOrderDesc
        };

        // We know we are recursive, but all our subdirectory queries will not be recursive.
        this->param.recursive = false;
    OBJ_NEW_END();

    return this;
}

/***********************************************************************************************************************************
Construct a "lazy-container" of files which will be found by scanning through a single subdirectory.
This constructor is used for recursively scanning through a directory hierarchy.
 @param parent - the current directory
 @param subdirInfo - information about the subdirectory, including its name.
 @return - an object defining the collection of files which will be found by scanning the subdirectory.
***********************************************************************************************************************************/
static SubdirItr *
subdirNew(RecursiveScanItr *rootItr, SubdirItr *parent, StorageInfo *info)
{
    // Point to the root of our scan.
    RecursiveScan *root = rootItr->scan;

    SubdirItr *this;
    OBJ_NEW_BEGIN(SubdirItr, .childQty=MEM_CONTEXT_QTY_MAX, .allocQty=MEM_CONTEXT_QTY_MAX)

        // Get the path to this subdirectory.
        String *relPath = (parent && info) ? strPathJoin(parent->path, info->name) : NULL;

        // Fetch the collection of files in this subdirectory.
        String *fullPath = strPathJoin(root->path, relPath);
        Collection *files = storageScan(root->driver, fullPath, root->param);
        strFree(fullPath);  // Probably not necessary.

        // Create the subdirectory helper for iterating through them.
        this = OBJ_NEW_ALLOC();
        *this = (SubdirItr) {
            .files = collectionItrNew(files),
            .postponed = NULL,
            .parent = parent,
            .path = relPath,
        };
    OBJ_NEW_END();

    return this;
}

/***********************************************************************************************************************************
Construct an iterator for recursively scanning through a directory tree
***********************************************************************************************************************************/
RecursiveScanItr *
recursiveScanItrNew(RecursiveScan *scan)
{
    RecursiveScanItr* this;
    OBJ_NEW_BEGIN(RecursiveScanItr, .childQty=MEM_CONTEXT_QTY_MAX, .allocQty=MEM_CONTEXT_QTY_MAX)
        this = OBJ_NEW_ALLOC();
        *this = (RecursiveScanItr) {
                .scan = scan,
                .info = NULL,
                .current = NULL,
                .ctx = memContextCurrent()
        };
        this->current = subdirNew(this, NULL, NULL),
    OBJ_NEW_END();

    return this;
}

/***********************************************************************************************************************************
Get the next item from the current directory, popping or pushing directories as appropriate.
***********************************************************************************************************************************/
static StorageInfo *
recursiveScanItrNext(RecursiveScanItr *this)
{
    // Free up the results from previous iteration.
    if (this->info != NULL)
        objFree(this->info);
    this->info = NULL;

    // Switch to the loop control context since we are going to allocate memory.
    MEM_CONTEXT_BEGIN(this->ctx)
    
        // Keep moving forward while there are more directories to examine.
        StorageInfo *info = NULL;
        while (this->current != NULL)
        {
            // Get the next file from the current directory.
            // TODO: have it return with directory name filled in.
            // TODO: so we use this->info instead of info, and we free it here before setting it again.
            info = collectionItrNext(this->current->files);

            // CASE: finished scanning current directory.
            if (info == NULL)
            {
                // Pop the current directory since it is now processed.
                SubdirItr *parent = this->current->parent;
                objFree(this->current);  // was allocated in loop control ctx, so it must be freed.
                this->current = parent;
                
                // If there are no more directories, then we're done scanning.
                if (this->current == NULL)
                    break;

                // if an item was postponed earlier, then output it now.  (typically, post-order directory)
                if (this->current->postponed != NULL) {
                    info = this->current->postponed;
                    this->current->postponed = NULL;
                    break;
                }
            }

            // CASE: encountered a subdirectory.
            else if (info->type == storageTypePath)
            {
                // If post-order, then postpone processing the directory.
                if (this->scan->postOrder)
                    this->current->postponed = info;
                
                // Start scanning the subdirectory.
                this->current = subdirNew(this, this->current, info);  // Will be freed when we finish scanning this subdir

                // If pre-order then output the directory now.
                if (!this->scan->postOrder) {
                    info->name = NULL;  // TODO: memory leak? Don't repeat the directory from info and again from current->path.
                    break;
                }
            }

            // OTHERWISE: file or link. Just return the file retVal.
            else
                break;
        }

        // At this point, we have found retVal for the next file. The retVal is possibly null.
        // For our return value, change the retVal name to include the subpath from where we started scanning.
        if (info != NULL)
           this->info = storageInfoUpdatePath(info, this->current->path); // Reminder: Will be freed next iteration.

    MEM_CONTEXT_END();

    // Return a pointer to the file retVal. It is stable until the next iteration.
    return this->info;
}



/***********************************************************************************************************************************
As a short term hack, use the List function to get a flat directory for each type of storage.
***********************************************************************************************************************************/
static Collection *
simpleScan(Storage *this, String *path, StorageScanParams param)
{
    StorageList *list = storageInterfaceListP(this, path, param.level);
    if (param.sortOrder != sortOrderNone)                           // TODO: push sort decisions into storageLstSort.
        storageLstSort(list, param.sortOrder);
    Collection *collection = collectionNew(StorageList, list);
    return collection;
}

Collection *
storageScan(Storage *this, String *path, struct StorageScanParams param)
{
    if (param.recursive)
        return collectionNew(RecursiveScan, recursiveScanNew(this, path, param));
    else
        return simpleScan(this, path, param);
}
