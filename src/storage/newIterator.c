/***********************************************************************************************************************************
Recursive scan of a directory.
***********************************************************************************************************************************/
#include "build.auto.h"

#include "storage/newIterator.h"
#include "storage/storage.h"
#include "storage/list.h"
#include "storage/info.h"
#include "common/type/string.h"
#include "common/type/object.h"
#include "common/regExp.h"

/****Belongs in string.h  or a path manipulation library.  ******/

/***********************************************************************************************************************************

 * @param path
 * @param subPath
***********************************************************************************************************************************/
static String *
strPathJoin(const String *path, const String *subPath)
{
    String *joined;
    if (path == NULL && subPath == NULL)
        joined = NULL;
    else if (path == NULL)
        joined = strDup(subPath);
    else if (subPath == NULL)
        joined = strDup(path);
    else
        joined = strNewFmt("%s/%s", strZ(path), strZ(subPath));

    return joined;
}

/*** belongs in storage/list.h. Enables iterating through StorageList **********/

// Convert StorageList to an abstract Collection.
FN_INLINE_ALWAYS Collection *
storageLstToCollection(StorageList *this)
{
    return collectionNew(List, THIS_PUB(StorageList)->list);
}


StorageInfo *
storageInfoAddPath(StorageInfo *info, String *parentPath)
{
    StorageInfo *this;
    OBJ_NEW_BEGIN(StorageInfo)

        // Copy everything except the name. TODO: This copy can be refined by looking at retVal level.
        this = OBJ_NEW_ALLOC();
        *this = *info;

        // Fill in the complete name by joining the directory path with the file name.
        this->name = strPathJoin(parentPath, info->name);
    OBJ_NEW_END();

    return this;
}

StorageInfo *
storageInfoClone(StorageInfo *info)
{
    return (info == NULL)? NULL: storageInfoAddPath(info, NULL);
}

/*******************************************************************************************************************************
Read the contents of a single directory.
 @param this the storage driver
 @param path the path to the directory
 @param .level how detailed should the retVal be
 @param .sortOrder desired sort order
 @param .followLink should we follow links or report them as links.
 @return Collection of file retVal.

This method will eventually be an interface which replaces storageInterfaceList (or upgrades it?)
***********************************************************************************************************************************/
#define storageInterfaceScanDirP(this, path, ...)                                                                                  \
    storageInterfaceScanDir(this, path, (StorageScanDirParams){VAR_PARAM_INIT, __VA_ARGS__})

typedef struct StorageScanDirParams
{
    int dummy;
    StorageInfoLevel level;
    bool followLink;
    SortOrder sortOrder;
    RegExp *expression;
} StorageScanDirParams;

Collection *
storageInterfaceScanDir(Storage *this, String *path, struct StorageScanDirParams param)
{
    StorageList *list = storageInterfaceListP(this, path, param.level);
    if (param.sortOrder != sortOrderNone)                           // TODO: push sort decisions into storageLstSort.
        storageLstSort(list, param.sortOrder);
    Collection *collection = storageLstToCollection(list);
    return collection;
}

/***** Now we are doing our own thing ***************/

/***********************************************************************************************************************************
A "lazy-container" of files which will be generated by recursively scanning through a directory.
***********************************************************************************************************************************/
typedef struct ScanDir
{
    Storage *driver;                                                // The relevant storage driver
    String *path;                                                   // Path to the relevant directory
    StorageInfoLevel level;                                         // Level of information details to provide for each file.
    SortOrder sortOrder;                                            // The desired order of the files.
    bool followLink;                                                // Should the scan follow symbolic links?
    bool postOrder;                                                 // Does the directory follow the contents?
} ScanDir;

// Enable use of FOREACH and conntainerNew().
#define CAMEL_ScanDir scanDir

/***********************************************************************************************************************************
A "helper-iterator" to scan files contained in a single directory.
***********************************************************************************************************************************/
typedef struct SubdirItr
{
    CollectionItr *files;                                           // Iterator scanning each file in directory.

    // The following fields are all NULL for the root directory.
    struct SubdirItr *parent;                                       // Pointer to our parent directory iterator.
    String *path;                                                   // Path to the current directory, relative to start.
    StorageInfo *dirInfo;                                           // Info for the current directory.
} SubdirItr;


/***********************************************************************************************************************************
"lazy iterator" to recursively scan through a directory and its subdirectories.
***********************************************************************************************************************************/
typedef struct ScanDirItr
{
    ScanDir *dir;                                                   // Point to the scan we are doing.
    SubdirItr *current;                                             // the current subdirectory iterator.
    StorageInfo *retVal;                                              // The file info we output last iteration.
    MemContext *ctx;                                                // Memory context of the iterator.
} ScanDirItr;

/***********************************************************************************************************************************
Construct a "lazy-container" of files which will be found by recursively scanning through the directory.
***********************************************************************************************************************************/
ScanDir *
scanDirNew(Storage *driver, String *path, StorageInfoLevel level, SortOrder sortOrder, bool followLink)
{
    ScanDir *this;
    OBJ_NEW_BEGIN(ScanDir)
        this = OBJ_NEW_ALLOC();
        *this = (ScanDir) {
            .driver = driver,
            .path = strDup(path),
            .level = level,
            .sortOrder = sortOrder,
            .followLink = followLink,
            .postOrder = sortOrder != sortOrderDesc;
        };
    OBJ_NEW_END();

    return this;
}

/***********************************************************************************************************************************
Construct a "lazy-container" of files which will be found by scanning through a single subdirectory.
This constructor is used for recursively scanning through a directory hierarchy.
 @param parent - the current directory
 @param subdirInfo - information about the subdirectory, including its name.
 @return - an object defining the collection of files which will be found by scanning the subdirectory.
***********************************************************************************************************************************/
static SubdirItr *
subdirNew(ScanDirItr *rootItr, SubdirItr *parent, StorageInfo *info)
{
    // Point to the root of our scan.
    ScanDir *root = rootItr->dir;

    SubdirItr *this;
    OBJ_NEW_BEGIN(SubdirItr)

        // We want our own copy of storage retVal since we going to save it.
        info = (info == NULL)? NULL: storageInfoClone(info);        // Repeatedly testing for the root case. Can we refactor?

        // Get the path to this subdirectory.
        String *relPath = (parent && info) ? strPathJoin(parent->path, info->name) : NULL;

        // Fetch the collection of files in this subdirectory.
        String *fullPath = strPathJoin(root->path, relPath);
        Collection *files = storageInterfaceScanDirP(root->driver, fullPath, root->level, .followLink=root->followLink, .sortOrder=root->sortOrder);
        strFree(fullPath);  // Probably not necessary.

        // Create the subdirectory helper for iterating through them.
        this = OBJ_NEW_ALLOC();
        *this = (SubdirItr) {
            .files = collectionItrNew(files),
            .parent = parent,
            .path = relPath,
            .dirInfo = info,
        };
    OBJ_NEW_END();

    return this;
}

/***********************************************************************************************************************************
Get the next file retVal from a subdirectory help iterator.
***********************************************************************************************************************************/
StorageInfo *
subdirItrNext(ScanDirItr *this)
{
    return collectionItrNext(this->current->files);
}

/***********************************************************************************************************************************
Construct an iterator for recursively scanning through a directory tree
***********************************************************************************************************************************/
ScanDirItr *
ScanDirItrNew(ScanDir *dir)
{
    ScanDirItr* this;
    OBJ_NEW_BEGIN(ScanDirItr)
        this = OBJ_NEW_ALLOC();
        *this = (ScanDirItr) {
                .dir = dir,
                .retVal = NULL,
                .current = subdirNew(this, NULL, NULL)
        };
    OBJ_NEW_END();

    return this;
}

/***********************************************************************************************************************************
Get the next item from the current directory, popping or pushing directories as appropriate.
***********************************************************************************************************************************/
static StorageInfo *
ScanDirItrNext(ScanDirItr *this)
{
    // Switch to the loop control context.
    MEM_CONTEXT_BEGIN(this->ctx)

        // Free the value returned from the previous iteration.
        if (this->retVal != NULL)
            objFree(this->retVal);
        this->retVal = NULL;

        // Keep moving forward while there are more directories to examine.
        StorageInfo *info = NULL;
        while (this->current != NULL)
        {
            // Free up storage retVal if it was allocated earlier.
            if (info != NULL)
                objFree(info);

            // Get the next file from the current directory.
            info = collectionItrNext(this->current->files);

            // CASE: finished scanning current directory.
            if (info == NULL)
            {
                // If post order (and not the root), then we need to output the directory information next since we just finished the contents.
                if (this->dir->postOrder && this->current->parent != NULL)
                     info = storageInfoClone(this->current->dirInfo);   // Reminder: must be freed.

                // Pop the current directory since it is now processed.
                SubdirItr *parent = this->current->parent;
                objFree(this->current);  // was allocated in loop control ctx, so it must be freed.
                this->current = parent;

                // if post-order, then output retVal for the directory retVal now. If root, we will return NULL;
                if (this->dir->postOrder)
                    break;
            }

            // CASE: encountered a subdirectory.
            else if (info->type == storageTypePath)
            {
                // Start scanning the subdirectory.
                this->current = subdirNew(this, this->current, info);  // Will be freed when we finish scanning this subdir

                // If we are pre-order then output the directory retVal now, before we scan the subdirectory.
                if (!this->dir->postOrder)
                    break;
            }

            // OTHERWISE: file or link. Just return the file retVal.
            else
                break;
        }

        // At this point, we have found retVal for the next file. The retVal is possibly null.
        // For our return value, change the retVal name to include the subpath from where we started scanning.
        if (info != NULL)
        {
           this->retVal = storageInfoAddPath(info, this->current->path); // Reminder: Will be freed next iteration.
           objFree(info);   // Reminder: free everything allocated in ItrNext()
        }
    MEM_CONTEXT_END();

    // Return a pointer to the file retVal. It is stable until the next iteration.
    return this->retVal;
}
